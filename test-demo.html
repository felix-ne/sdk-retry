<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDK é‡è¯•é˜Ÿåˆ—æµ‹è¯•æ¼”ç¤º</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-top: 0;
        }
        h2 {
            color: #666;
            font-size: 18px;
            margin-top: 24px;
            border-bottom: 2px solid #eee;
            padding-bottom: 8px;
        }
        .button-group {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin: 16px 0;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        .btn-primary {
            background: #007AFF;
            color: white;
        }
        .btn-success {
            background: #34C759;
            color: white;
        }
        .btn-danger {
            background: #FF3B30;
            color: white;
        }
        .btn-warning {
            background: #FF9500;
            color: white;
        }
        .btn-secondary {
            background: #8E8E93;
            color: white;
        }
        .status {
            background: #f8f9fa;
            border-radius: 4px;
            padding: 16px;
            margin: 16px 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
        }
        .status pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .log {
            background: #1e1e1e;
            color: #d4d4d4;
            border-radius: 4px;
            padding: 16px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
        }
        .log-entry {
            margin: 4px 0;
            padding: 4px;
        }
        .log-entry.success {
            color: #4EC9B0;
        }
        .log-entry.error {
            color: #F48771;
        }
        .log-entry.info {
            color: #9CDCFE;
        }
        .log-entry.warning {
            color: #CE9178;
        }
        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            margin-right: 8px;
        }
        .badge-success {
            background: #34C759;
            color: white;
        }
        .badge-error {
            background: #FF3B30;
            color: white;
        }
        .badge-info {
            background: #007AFF;
            color: white;
        }
        .badge-warning {
            background: #FF9500;
            color: white;
        }
        .info-box {
            background: #E3F2FD;
            border-left: 4px solid #2196F3;
            padding: 12px 16px;
            margin: 16px 0;
            border-radius: 4px;
        }
        .network-status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: bold;
        }
        .network-online {
            background: #D1F2EB;
            color: #0E6655;
        }
        .network-offline {
            background: #FADBD8;
            color: #922B21;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”„ SDK é‡è¯•é˜Ÿåˆ—æµ‹è¯•æ¼”ç¤º</h1>
        
        <div class="info-box">
            <strong>è¯´æ˜ï¼š</strong> è¿™æ˜¯ä¸€ä¸ªäº¤äº’å¼æ¼”ç¤ºï¼Œç”¨äºæµ‹è¯• SDK é‡è¯•é˜Ÿåˆ—çš„å„ç§åŠŸèƒ½ã€‚
            ä½ å¯ä»¥æ¨¡æ‹Ÿç½‘ç»œçŠ¶æ€ã€å‘é€æˆåŠŸ/å¤±è´¥çš„è¯·æ±‚ï¼Œè§‚å¯Ÿé˜Ÿåˆ—çš„è¡Œä¸ºã€‚
        </div>

        <h2>ç½‘ç»œçŠ¶æ€æ§åˆ¶</h2>
        <div class="button-group">
            <button class="btn-success" onclick="setOnline()">âœ… è®¾ä¸ºåœ¨çº¿</button>
            <button class="btn-danger" onclick="setOffline()">âŒ è®¾ä¸ºç¦»çº¿</button>
            <span style="margin-left: 12px; line-height: 40px;">
                å½“å‰çŠ¶æ€: <span id="networkStatus" class="network-status network-online">åœ¨çº¿</span>
            </span>
        </div>

        <h2>å‘é€æµ‹è¯•è¯·æ±‚</h2>
        <div class="button-group">
            <button class="btn-primary" onclick="sendSuccessRequest()">âœ… å‘é€æˆåŠŸè¯·æ±‚</button>
            <button class="btn-danger" onclick="sendFailRequest()">âŒ å‘é€å¤±è´¥è¯·æ±‚</button>
            <button class="btn-warning" onclick="sendBatch()">ğŸ“¦ æ‰¹é‡å‘é€10ä¸ªå¤±è´¥è¯·æ±‚</button>
        </div>

        <h2>é˜Ÿåˆ—æ“ä½œ</h2>
        <div class="button-group">
            <button class="btn-primary" onclick="updateStatus()">ğŸ”„ åˆ·æ–°çŠ¶æ€</button>
            <button class="btn-warning" onclick="flushQueue()">âš¡ æ‰‹åŠ¨è§¦å‘è¡¥å‘</button>
            <button class="btn-danger" onclick="clearQueue()">ğŸ—‘ï¸ æ¸…ç©ºé˜Ÿåˆ—</button>
            <button class="btn-secondary" onclick="clearLog()">ğŸ§¹ æ¸…ç©ºæ—¥å¿—</button>
        </div>

        <h2>é˜Ÿåˆ—çŠ¶æ€</h2>
        <div class="status">
            <pre id="queueStatus">åŠ è½½ä¸­...</pre>
        </div>

        <h2>æ“ä½œæ—¥å¿—</h2>
        <div class="log" id="logContainer">
            <div class="log-entry info">ç­‰å¾…æ“ä½œ...</div>
        </div>
    </div>

    <script>
        // ç®€åŒ–ç‰ˆ RetryQueue å®ç°ï¼ˆç”¨äºæ¼”ç¤ºï¼‰
        class SimpleRetryQueue {
            constructor() {
                this.queue = this.loadFromStorage();
                this.storageKey = 'demo_retry_queue';
                this.maxRetries = 3;
                this.isProcessing = false;
                
                // ç›‘å¬ç½‘ç»œçŠ¶æ€
                window.addEventListener('online', () => {
                    this.log('ç½‘ç»œå·²æ¢å¤', 'success');
                    this.processQueue();
                });
            }

            loadFromStorage() {
                try {
                    const data = localStorage.getItem('demo_retry_queue');
                    return data ? JSON.parse(data) : [];
                } catch {
                    return [];
                }
            }

            saveToStorage() {
                localStorage.setItem(this.storageKey, JSON.stringify(this.queue));
            }

            enqueue(payload) {
                const item = {
                    id: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    payload,
                    retryCount: 0,
                    createdAt: Date.now(),
                };
                this.queue.push(item);
                this.saveToStorage();
                this.log(`è¯·æ±‚å·²åŠ å…¥é˜Ÿåˆ— (ID: ${item.id.substr(0, 16)}...)`, 'warning');
                return item;
            }

            async processQueue() {
                if (this.isProcessing || this.queue.length === 0) {
                    return;
                }

                if (!navigator.onLine) {
                    this.log('ç½‘ç»œç¦»çº¿ï¼Œè·³è¿‡é˜Ÿåˆ—å¤„ç†', 'warning');
                    return;
                }

                this.isProcessing = true;
                this.log(`å¼€å§‹å¤„ç†é˜Ÿåˆ— (${this.queue.length} ä¸ªè¯·æ±‚)`, 'info');

                const promises = this.queue.slice(0, 3).map(item => this.retryItem(item));
                await Promise.allSettled(promises);

                this.isProcessing = false;
                this.saveToStorage();
                updateStatus();
            }

            async retryItem(item) {
                this.log(`é‡è¯•è¯·æ±‚ ${item.id.substr(0, 16)}... (ç¬¬ ${item.retryCount + 1} æ¬¡)`, 'info');

                try {
                    const response = await fetch(item.payload.url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(item.payload.body),
                    });

                    if (response.ok) {
                        this.removeItem(item.id);
                        this.log(`âœ… è¯·æ±‚æˆåŠŸ ${item.id.substr(0, 16)}...`, 'success');
                    } else {
                        this.incrementRetry(item.id);
                        this.log(`âŒ è¯·æ±‚å¤±è´¥ ${item.id.substr(0, 16)}... (çŠ¶æ€: ${response.status})`, 'error');
                    }
                } catch (error) {
                    this.incrementRetry(item.id);
                    this.log(`âŒ è¯·æ±‚å¼‚å¸¸ ${item.id.substr(0, 16)}... (${error.message})`, 'error');
                }
            }

            removeItem(id) {
                const index = this.queue.findIndex(item => item.id === id);
                if (index !== -1) {
                    this.queue.splice(index, 1);
                }
            }

            incrementRetry(id) {
                const item = this.queue.find(item => item.id === id);
                if (item) {
                    item.retryCount++;
                    if (item.retryCount >= this.maxRetries) {
                        this.removeItem(id);
                        this.log(`æ”¾å¼ƒè¯·æ±‚ ${id.substr(0, 16)}... (å·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°)`, 'error');
                    }
                }
            }

            getStatus() {
                return {
                    queueSize: this.queue.length,
                    isProcessing: this.isProcessing,
                    items: this.queue.map(item => ({
                        id: item.id.substr(0, 20) + '...',
                        url: item.payload.url,
                        retryCount: item.retryCount,
                        age: Math.floor((Date.now() - item.createdAt) / 1000) + 's',
                    })),
                };
            }

            clear() {
                this.queue = [];
                this.saveToStorage();
                this.log('é˜Ÿåˆ—å·²æ¸…ç©º', 'info');
            }

            log(message, type = 'info') {
                const logContainer = document.getElementById('logContainer');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                
                const time = new Date().toLocaleTimeString();
                const badge = `<span class="badge badge-${type}">${type.toUpperCase()}</span>`;
                entry.innerHTML = `[${time}] ${badge} ${message}`;
                
                logContainer.appendChild(entry);
                logContainer.scrollTop = logContainer.scrollHeight;
            }
        }

        // å…¨å±€å®ä¾‹
        const retryQueue = new SimpleRetryQueue();

        // æ›´æ–°ç½‘ç»œçŠ¶æ€æ˜¾ç¤º
        function updateNetworkStatus() {
            const statusEl = document.getElementById('networkStatus');
            if (navigator.onLine) {
                statusEl.textContent = 'åœ¨çº¿';
                statusEl.className = 'network-status network-online';
            } else {
                statusEl.textContent = 'ç¦»çº¿';
                statusEl.className = 'network-status network-offline';
            }
        }

        // è®¾ç½®åœ¨çº¿
        function setOnline() {
            Object.defineProperty(navigator, 'onLine', {
                writable: true,
                configurable: true,
                value: true,
            });
            updateNetworkStatus();
            window.dispatchEvent(new Event('online'));
            retryQueue.log('å·²åˆ‡æ¢åˆ°åœ¨çº¿æ¨¡å¼', 'success');
        }

        // è®¾ç½®ç¦»çº¿
        function setOffline() {
            Object.defineProperty(navigator, 'onLine', {
                writable: true,
                configurable: true,
                value: false,
            });
            updateNetworkStatus();
            retryQueue.log('å·²åˆ‡æ¢åˆ°ç¦»çº¿æ¨¡å¼', 'warning');
        }

        // å‘é€æˆåŠŸè¯·æ±‚
        async function sendSuccessRequest() {
            retryQueue.log('å‘é€æˆåŠŸè¯·æ±‚åˆ° httpbin.org...', 'info');
            try {
                const response = await fetch('https://httpbin.org/post', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ event: 'test_success', timestamp: Date.now() }),
                });
                
                if (response.ok) {
                    retryQueue.log('âœ… è¯·æ±‚æˆåŠŸï¼', 'success');
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                retryQueue.log(`âŒ è¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
            }
            updateStatus();
        }

        // å‘é€å¤±è´¥è¯·æ±‚
        async function sendFailRequest() {
            retryQueue.log('å‘é€å¤±è´¥è¯·æ±‚ï¼ˆå°†åŠ å…¥é˜Ÿåˆ—ï¼‰...', 'info');
            
            // æ¨¡æ‹Ÿå¤±è´¥ååŠ å…¥é˜Ÿåˆ—
            retryQueue.enqueue({
                url: 'https://httpbin.org/status/500', // æ•…æ„è¿”å› 500
                body: { event: 'test_fail', timestamp: Date.now() },
            });
            
            updateStatus();
        }

        // æ‰¹é‡å‘é€
        function sendBatch() {
            retryQueue.log('æ‰¹é‡æ·»åŠ  10 ä¸ªå¤±è´¥è¯·æ±‚åˆ°é˜Ÿåˆ—...', 'info');
            for (let i = 0; i < 10; i++) {
                retryQueue.enqueue({
                    url: 'https://httpbin.org/status/500',
                    body: { event: `batch_${i}`, timestamp: Date.now() },
                });
            }
            updateStatus();
        }

        // æ›´æ–°çŠ¶æ€
        function updateStatus() {
            const status = retryQueue.getStatus();
            const statusEl = document.getElementById('queueStatus');
            statusEl.textContent = JSON.stringify(status, null, 2);
        }

        // æ‰‹åŠ¨è§¦å‘è¡¥å‘
        async function flushQueue() {
            retryQueue.log('æ‰‹åŠ¨è§¦å‘é˜Ÿåˆ—è¡¥å‘...', 'info');
            await retryQueue.processQueue();
        }

        // æ¸…ç©ºé˜Ÿåˆ—
        function clearQueue() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºé˜Ÿåˆ—å—ï¼Ÿ')) {
                retryQueue.clear();
                updateStatus();
            }
        }

        // æ¸…ç©ºæ—¥å¿—
        function clearLog() {
            const logContainer = document.getElementById('logContainer');
            logContainer.innerHTML = '<div class="log-entry info">æ—¥å¿—å·²æ¸…ç©º</div>';
        }

        // åˆå§‹åŒ–
        updateNetworkStatus();
        updateStatus();
        retryQueue.log('æ¼”ç¤ºé¡µé¢å·²åŠ è½½ï¼Œå¯ä»¥å¼€å§‹æµ‹è¯•', 'success');
    </script>
</body>
</html>



